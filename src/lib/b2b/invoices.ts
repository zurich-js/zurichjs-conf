/**
 * B2B Invoice Business Logic
 * Core operations for managing B2B invoices
 */

import { createServiceRoleClient } from '@/lib/supabase';
import type {
  B2BInvoice,
  B2BInvoiceWithAttendees,
  B2BInvoiceStatus,
  CreateB2BInvoiceRequest,
  UpdateB2BInvoiceRequest,
  ListInvoicesQuery,
} from '@/lib/types/b2b';

/**
 * Create a new B2B invoice
 *
 * @param data - Invoice creation data
 * @returns Created invoice with auto-generated invoice number
 * @throws Error if validation fails or database insert fails
 */
export async function createInvoice(data: CreateB2BInvoiceRequest): Promise<B2BInvoice> {
  const supabase = createServiceRoleClient();

  // Calculate totals
  const subtotal = data.unitPrice * data.ticketQuantity;
  const vatRate = data.vatRate ?? 0;
  const vatAmount = Math.round(subtotal * (vatRate / 100));
  const totalAmount = subtotal + vatAmount;

  const { data: invoice, error } = await supabase
    .from('b2b_invoices')
    .insert({
      // Invoice number is auto-generated by database trigger when empty
      invoice_number: '',

      // Company details
      company_name: data.companyName,
      vat_id: data.vatId || null,
      billing_address_street: data.billingAddress.street,
      billing_address_city: data.billingAddress.city,
      billing_address_postal_code: data.billingAddress.postalCode,
      billing_address_country: data.billingAddress.country,

      // Contact
      contact_name: data.contactName,
      contact_email: data.contactEmail,

      // Invoice settings
      due_date: data.dueDate,
      notes: data.notes || null,
      invoice_notes: data.invoiceNotes || null,
      payment_method: data.paymentMethod || 'bank_transfer',

      // Ticket configuration
      ticket_category: data.ticketCategory,
      ticket_stage: data.ticketStage,
      ticket_quantity: data.ticketQuantity,
      unit_price: data.unitPrice,
      currency: 'CHF',

      // Calculated totals
      subtotal,
      vat_rate: vatRate,
      vat_amount: vatAmount,
      total_amount: totalAmount,

      // Default status
      status: 'draft',
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating invoice:', error);
    throw new Error(`Failed to create invoice: ${error.message}`);
  }

  return invoice as B2BInvoice;
}

/**
 * Get a single invoice by ID
 *
 * @param invoiceId - UUID of the invoice
 * @returns Invoice or null if not found
 */
export async function getInvoice(invoiceId: string): Promise<B2BInvoice | null> {
  const supabase = createServiceRoleClient();

  const { data, error } = await supabase
    .from('b2b_invoices')
    .select('*')
    .eq('id', invoiceId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return null; // Not found
    }
    console.error('Error fetching invoice:', error);
    throw new Error(`Failed to fetch invoice: ${error.message}`);
  }

  return data as B2BInvoice;
}

/**
 * Get invoice with all attendees
 *
 * @param invoiceId - UUID of the invoice
 * @returns Invoice with attendees or null if not found
 */
export async function getInvoiceWithAttendees(
  invoiceId: string
): Promise<B2BInvoiceWithAttendees | null> {
  const supabase = createServiceRoleClient();

  // Fetch invoice
  const { data: invoice, error: invoiceError } = await supabase
    .from('b2b_invoices')
    .select('*')
    .eq('id', invoiceId)
    .single();

  if (invoiceError) {
    if (invoiceError.code === 'PGRST116') {
      return null;
    }
    throw new Error(`Failed to fetch invoice: ${invoiceError.message}`);
  }

  // Fetch attendees
  const { data: attendees, error: attendeesError } = await supabase
    .from('b2b_invoice_attendees')
    .select('*')
    .eq('invoice_id', invoiceId)
    .order('created_at', { ascending: true });

  if (attendeesError) {
    throw new Error(`Failed to fetch attendees: ${attendeesError.message}`);
  }

  return {
    ...invoice,
    attendees: attendees || [],
  } as B2BInvoiceWithAttendees;
}

/**
 * List invoices with optional filtering and pagination
 *
 * @param query - Query parameters for filtering
 * @returns List of invoices and total count
 */
export async function listInvoices(query: ListInvoicesQuery = {}): Promise<{
  invoices: B2BInvoice[];
  total: number;
}> {
  const supabase = createServiceRoleClient();
  const { status, search, page = 1, limit = 20 } = query;

  let queryBuilder = supabase.from('b2b_invoices').select('*', { count: 'exact' });

  // Filter by status
  if (status) {
    queryBuilder = queryBuilder.eq('status', status);
  }

  // Search by company name or invoice number
  if (search) {
    queryBuilder = queryBuilder.or(
      `company_name.ilike.%${search}%,invoice_number.ilike.%${search}%`
    );
  }

  // Pagination
  const offset = (page - 1) * limit;
  queryBuilder = queryBuilder
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);

  const { data, error, count } = await queryBuilder;

  if (error) {
    console.error('Error listing invoices:', error);
    throw new Error(`Failed to list invoices: ${error.message}`);
  }

  return {
    invoices: (data || []) as B2BInvoice[],
    total: count || 0,
  };
}

/**
 * Update an existing invoice
 * Only allowed for invoices in draft or sent status
 *
 * @param invoiceId - UUID of the invoice
 * @param data - Fields to update
 * @returns Updated invoice
 * @throws Error if invoice is in paid/cancelled status
 */
export async function updateInvoice(
  invoiceId: string,
  data: UpdateB2BInvoiceRequest
): Promise<B2BInvoice> {
  const supabase = createServiceRoleClient();

  // First, check current status
  const existing = await getInvoice(invoiceId);
  if (!existing) {
    throw new Error('Invoice not found');
  }

  if (existing.status === 'paid' || existing.status === 'cancelled') {
    throw new Error(`Cannot update invoice with status: ${existing.status}`);
  }

  // Build update object
  const updateData: Record<string, unknown> = {};

  if (data.companyName !== undefined) updateData.company_name = data.companyName;
  if (data.vatId !== undefined) updateData.vat_id = data.vatId || null;
  if (data.contactName !== undefined) updateData.contact_name = data.contactName;
  if (data.contactEmail !== undefined) updateData.contact_email = data.contactEmail;
  if (data.dueDate !== undefined) updateData.due_date = data.dueDate;
  if (data.notes !== undefined) updateData.notes = data.notes || null;
  if (data.invoiceNotes !== undefined) updateData.invoice_notes = data.invoiceNotes || null;
  if (data.paymentMethod !== undefined) updateData.payment_method = data.paymentMethod;
  if (data.ticketCategory !== undefined) updateData.ticket_category = data.ticketCategory;
  if (data.ticketStage !== undefined) updateData.ticket_stage = data.ticketStage;

  // Handle billing address partial updates
  if (data.billingAddress) {
    if (data.billingAddress.street !== undefined) {
      updateData.billing_address_street = data.billingAddress.street;
    }
    if (data.billingAddress.city !== undefined) {
      updateData.billing_address_city = data.billingAddress.city;
    }
    if (data.billingAddress.postalCode !== undefined) {
      updateData.billing_address_postal_code = data.billingAddress.postalCode;
    }
    if (data.billingAddress.country !== undefined) {
      updateData.billing_address_country = data.billingAddress.country;
    }
  }

  // Recalculate totals if pricing fields changed
  const unitPrice = data.unitPrice ?? existing.unit_price;
  const ticketQuantity = data.ticketQuantity ?? existing.ticket_quantity;
  const vatRate = data.vatRate ?? existing.vat_rate;

  if (
    data.unitPrice !== undefined ||
    data.ticketQuantity !== undefined ||
    data.vatRate !== undefined
  ) {
    updateData.unit_price = unitPrice;
    updateData.ticket_quantity = ticketQuantity;
    updateData.vat_rate = vatRate;

    const subtotal = unitPrice * ticketQuantity;
    const vatAmount = Math.round(subtotal * (vatRate / 100));

    updateData.subtotal = subtotal;
    updateData.vat_amount = vatAmount;
    updateData.total_amount = subtotal + vatAmount;
  }

  const { data: updated, error } = await supabase
    .from('b2b_invoices')
    .update(updateData)
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    console.error('Error updating invoice:', error);
    throw new Error(`Failed to update invoice: ${error.message}`);
  }

  return updated as B2BInvoice;
}

/**
 * Update invoice status
 * Validates that the transition is allowed
 *
 * @param invoiceId - UUID of the invoice
 * @param newStatus - New status to set
 * @throws Error if transition is invalid
 */
export async function updateInvoiceStatus(
  invoiceId: string,
  newStatus: B2BInvoiceStatus
): Promise<B2BInvoice> {
  const supabase = createServiceRoleClient();

  // Get current invoice
  const existing = await getInvoice(invoiceId);
  if (!existing) {
    throw new Error('Invoice not found');
  }

  // Import and use the validation function
  const { isValidStatusTransition } = await import('@/lib/types/b2b');

  // Validate transition
  if (!isValidStatusTransition(existing.status, newStatus)) {
    throw new Error(
      `Invalid status transition: ${existing.status} -> ${newStatus}. ` +
        `Allowed transitions from ${existing.status}: ${
          existing.status === 'draft'
            ? 'sent, cancelled'
            : existing.status === 'sent'
              ? 'paid, cancelled'
              : 'none'
        }`
    );
  }

  const { data: updated, error } = await supabase
    .from('b2b_invoices')
    .update({ status: newStatus })
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    console.error('Error updating invoice status:', error);
    throw new Error(`Failed to update invoice status: ${error.message}`);
  }

  return updated as B2BInvoice;
}

/**
 * Delete an invoice
 * Only allowed for invoices in draft status
 *
 * @param invoiceId - UUID of the invoice
 * @throws Error if invoice is not in draft status
 */
export async function deleteInvoice(invoiceId: string): Promise<void> {
  const supabase = createServiceRoleClient();

  // Check current status
  const existing = await getInvoice(invoiceId);
  if (!existing) {
    throw new Error('Invoice not found');
  }

  if (existing.status !== 'draft') {
    throw new Error(`Cannot delete invoice with status: ${existing.status}. Only draft invoices can be deleted.`);
  }

  const { error } = await supabase.from('b2b_invoices').delete().eq('id', invoiceId);

  if (error) {
    console.error('Error deleting invoice:', error);
    throw new Error(`Failed to delete invoice: ${error.message}`);
  }
}

/**
 * Update invoice PDF details
 *
 * @param invoiceId - UUID of the invoice
 * @param pdfUrl - URL to the PDF file
 * @param source - Whether PDF was generated or uploaded
 */
export async function updateInvoicePDF(
  invoiceId: string,
  pdfUrl: string,
  source: 'generated' | 'uploaded'
): Promise<B2BInvoice> {
  const supabase = createServiceRoleClient();

  const { data: updated, error } = await supabase
    .from('b2b_invoices')
    .update({
      invoice_pdf_url: pdfUrl,
      invoice_pdf_source: source,
      invoice_pdf_uploaded_at: new Date().toISOString(),
    })
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    console.error('Error updating invoice PDF:', error);
    throw new Error(`Failed to update invoice PDF: ${error.message}`);
  }

  return updated as B2BInvoice;
}

/**
 * Update invoice Stripe payment link
 *
 * @param invoiceId - UUID of the invoice
 * @param paymentLinkId - Stripe Payment Link ID
 * @param paymentLinkUrl - Stripe Payment Link URL
 */
export async function updateStripePaymentLink(
  invoiceId: string,
  paymentLinkId: string,
  paymentLinkUrl: string
): Promise<B2BInvoice> {
  const supabase = createServiceRoleClient();

  const { data: updated, error } = await supabase
    .from('b2b_invoices')
    .update({
      stripe_payment_link_id: paymentLinkId,
      stripe_payment_link_url: paymentLinkUrl,
    })
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    console.error('Error updating Stripe payment link:', error);
    throw new Error(`Failed to update Stripe payment link: ${error.message}`);
  }

  return updated as B2BInvoice;
}

/**
 * Remove invoice PDF
 *
 * @param invoiceId - UUID of the invoice
 */
export async function removeInvoicePDF(invoiceId: string): Promise<B2BInvoice> {
  const supabase = createServiceRoleClient();

  const { data: updated, error } = await supabase
    .from('b2b_invoices')
    .update({
      invoice_pdf_url: null,
      invoice_pdf_source: null,
      invoice_pdf_uploaded_at: null,
    })
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    console.error('Error removing invoice PDF:', error);
    throw new Error(`Failed to remove invoice PDF: ${error.message}`);
  }

  return updated as B2BInvoice;
}
