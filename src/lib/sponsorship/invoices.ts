/**
 * Sponsorship Invoices Business Logic
 * Operations for managing sponsorship invoice records
 */

import { createServiceRoleClient } from '@/lib/supabase';
import type {
  SponsorshipInvoice,
  CreateInvoiceRequest,
  UpdateInvoiceConversionRequest,
  SponsorshipInvoicePDFSource,
  SponsorshipCurrency,
} from '@/lib/types/sponsorship';
import { computeSponsorshipInvoiceTotals } from './calculations';
import { getLineItemsForDeal } from './line-items';
import { getDeal } from './deals';
import { getTier } from './tiers';

// Validation constants
const MIN_CONVERSION_RATE = 0.1;
const MAX_CONVERSION_RATE = 10;

/**
 * Create an invoice for a deal
 * Calculates totals from current line items
 *
 * @param dealId - UUID of the deal
 * @param data - Invoice creation data
 * @returns Created invoice with auto-generated invoice number
 */
export async function createInvoice(
  dealId: string,
  data: CreateInvoiceRequest
): Promise<SponsorshipInvoice> {
  const supabase = createServiceRoleClient();

  // Check if invoice already exists for this deal
  const { data: existingInvoice } = await supabase
    .from('sponsorship_invoices')
    .select('id')
    .eq('deal_id', dealId)
    .single();

  if (existingInvoice) {
    throw new Error('Invoice already exists for this deal');
  }

  // Get deal details
  const deal = await getDeal(dealId);
  if (!deal) {
    throw new Error('Deal not found');
  }

  // Get tier for credit calculation
  const tier = await getTier(deal.tier_id);
  if (!tier) {
    throw new Error('Tier not found');
  }

  // Get line items and calculate totals
  const lineItems = await getLineItemsForDeal(dealId);
  const totals = computeSponsorshipInvoiceTotals(
    lineItems,
    tier,
    deal.currency as SponsorshipCurrency
  );

  // Build insert data
  let payableCurrency: string | null = null;
  let conversionRateChfToEur: number | null = null;
  let convertedAmountEur: number | null = null;
  let conversionJustification: string | null = null;
  let conversionRateSource: string | null = null;
  let conversionUpdatedAt: string | null = null;

  // Handle multi-currency conversion (CHF -> EUR)
  if (data.payInEur && deal.currency === 'CHF') {
    // Validate conversion fields
    if (!data.conversionRateChfToEur) {
      throw new Error('Conversion rate is required when paying in EUR');
    }
    if (data.conversionRateChfToEur <= MIN_CONVERSION_RATE || data.conversionRateChfToEur >= MAX_CONVERSION_RATE) {
      throw new Error(`Conversion rate must be between ${MIN_CONVERSION_RATE} and ${MAX_CONVERSION_RATE}`);
    }
    if (!data.conversionJustification?.trim()) {
      throw new Error('Conversion justification is required when paying in EUR');
    }

    // Calculate converted amount if not provided
    const calculatedAmount = data.convertedAmountEur ??
      Math.round(totals.total * data.conversionRateChfToEur);

    if (calculatedAmount <= 0) {
      throw new Error('Converted amount must be positive');
    }

    payableCurrency = 'EUR';
    conversionRateChfToEur = data.conversionRateChfToEur;
    convertedAmountEur = calculatedAmount;
    conversionJustification = data.conversionJustification.trim();
    conversionRateSource = data.conversionRateSource || 'manual';
    conversionUpdatedAt = new Date().toISOString();
  }

  const { data: invoice, error } = await supabase
    .from('sponsorship_invoices')
    .insert({
      deal_id: dealId,
      // Invoice number is auto-generated by database trigger when empty
      invoice_number: '',
      due_date: data.dueDate,
      subtotal: totals.subtotal,
      credit_applied: totals.creditApplied,
      adjustments_total: totals.adjustmentsTotal,
      total_amount: totals.total,
      currency: deal.currency,
      invoice_notes: data.invoiceNotes || null,
      // Always store base amount in CHF
      base_currency: 'CHF',
      base_amount_chf: deal.currency === 'CHF' ? totals.total : null,
      // Conversion fields (null if not paying in EUR)
      payable_currency: payableCurrency,
      conversion_rate_chf_to_eur: conversionRateChfToEur,
      converted_amount_eur: convertedAmountEur,
      conversion_justification: conversionJustification,
      conversion_rate_source: conversionRateSource,
      conversion_updated_at: conversionUpdatedAt,
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating invoice:', error);
    throw new Error(`Failed to create invoice: ${error.message}`);
  }

  return invoice as SponsorshipInvoice;
}

/**
 * Get an invoice by ID
 *
 * @param invoiceId - UUID of the invoice
 * @returns Invoice or null if not found
 */
export async function getInvoice(invoiceId: string): Promise<SponsorshipInvoice | null> {
  const supabase = createServiceRoleClient();

  const { data, error } = await supabase
    .from('sponsorship_invoices')
    .select('*')
    .eq('id', invoiceId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return null; // Not found
    }
    console.error('Error fetching invoice:', error);
    throw new Error(`Failed to fetch invoice: ${error.message}`);
  }

  return data as SponsorshipInvoice;
}

/**
 * Get the invoice for a deal
 *
 * @param dealId - UUID of the deal
 * @returns Invoice or null if not found
 */
export async function getInvoiceForDeal(
  dealId: string
): Promise<SponsorshipInvoice | null> {
  const supabase = createServiceRoleClient();

  const { data, error } = await supabase
    .from('sponsorship_invoices')
    .select('*')
    .eq('deal_id', dealId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return null; // Not found
    }
    console.error('Error fetching invoice for deal:', error);
    throw new Error(`Failed to fetch invoice: ${error.message}`);
  }

  return data as SponsorshipInvoice;
}

/**
 * Update invoice PDF URL
 *
 * @param invoiceId - UUID of the invoice
 * @param pdfUrl - URL of the uploaded/generated PDF
 * @param source - How the PDF was created
 * @returns Updated invoice
 */
export async function updateInvoicePDF(
  invoiceId: string,
  pdfUrl: string,
  source: SponsorshipInvoicePDFSource
): Promise<SponsorshipInvoice> {
  const supabase = createServiceRoleClient();

  const { data: invoice, error } = await supabase
    .from('sponsorship_invoices')
    .update({
      invoice_pdf_url: pdfUrl,
      invoice_pdf_source: source,
      invoice_pdf_uploaded_at: new Date().toISOString(),
    })
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    console.error('Error updating invoice PDF:', error);
    throw new Error(`Failed to update invoice PDF: ${error.message}`);
  }

  return invoice as SponsorshipInvoice;
}

/**
 * Remove invoice PDF reference
 *
 * @param invoiceId - UUID of the invoice
 * @returns Updated invoice
 */
export async function removeInvoicePDF(invoiceId: string): Promise<SponsorshipInvoice> {
  const supabase = createServiceRoleClient();

  const { data: invoice, error } = await supabase
    .from('sponsorship_invoices')
    .update({
      invoice_pdf_url: null,
      invoice_pdf_source: null,
      invoice_pdf_uploaded_at: null,
    })
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    console.error('Error removing invoice PDF:', error);
    throw new Error(`Failed to remove invoice PDF: ${error.message}`);
  }

  return invoice as SponsorshipInvoice;
}

/**
 * Update invoice details (due date, notes, issue date)
 *
 * @param invoiceId - UUID of the invoice
 * @param data - Fields to update
 * @returns Updated invoice
 */
export async function updateInvoice(
  invoiceId: string,
  data: { dueDate?: string; invoiceNotes?: string; issueDate?: string }
): Promise<SponsorshipInvoice> {
  const supabase = createServiceRoleClient();

  const updateData: Record<string, unknown> = {};
  if (data.dueDate !== undefined) updateData.due_date = data.dueDate;
  if (data.invoiceNotes !== undefined) updateData.invoice_notes = data.invoiceNotes;
  if (data.issueDate !== undefined) updateData.issue_date = data.issueDate;

  const { data: invoice, error } = await supabase
    .from('sponsorship_invoices')
    .update(updateData)
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    console.error('Error updating invoice:', error);
    throw new Error(`Failed to update invoice: ${error.message}`);
  }

  return invoice as SponsorshipInvoice;
}

/**
 * Update invoice currency conversion settings
 *
 * @param invoiceId - UUID of the invoice
 * @param data - Conversion settings
 * @param updatedBy - Admin making the change (for audit)
 * @returns Updated invoice
 */
export async function updateInvoiceConversion(
  invoiceId: string,
  data: UpdateInvoiceConversionRequest,
  updatedBy?: string
): Promise<SponsorshipInvoice> {
  const supabase = createServiceRoleClient();

  // Get current invoice to check deal currency
  const invoice = await getInvoice(invoiceId);
  if (!invoice) {
    throw new Error('Invoice not found');
  }

  // Get deal to verify it's CHF-based
  const deal = await getDeal(invoice.deal_id);
  if (!deal) {
    throw new Error('Deal not found');
  }

  // Only CHF deals can have EUR conversion
  if (deal.currency !== 'CHF' && data.payInEur) {
    throw new Error('Currency conversion is only available for CHF-based deals');
  }

  let updateData: Record<string, unknown>;

  if (data.payInEur) {
    // Validate conversion fields
    if (!data.conversionRateChfToEur) {
      throw new Error('Conversion rate is required when paying in EUR');
    }
    if (data.conversionRateChfToEur <= MIN_CONVERSION_RATE || data.conversionRateChfToEur >= MAX_CONVERSION_RATE) {
      throw new Error(`Conversion rate must be between ${MIN_CONVERSION_RATE} and ${MAX_CONVERSION_RATE}`);
    }
    if (!data.conversionJustification?.trim()) {
      throw new Error('Conversion justification is required when paying in EUR');
    }

    // Calculate converted amount if not provided
    const baseAmount = invoice.base_amount_chf ?? invoice.total_amount;
    const convertedAmount = data.convertedAmountEur ??
      Math.round(baseAmount * data.conversionRateChfToEur);

    if (convertedAmount <= 0) {
      throw new Error('Converted amount must be positive');
    }

    updateData = {
      payable_currency: 'EUR',
      conversion_rate_chf_to_eur: data.conversionRateChfToEur,
      converted_amount_eur: convertedAmount,
      conversion_justification: data.conversionJustification.trim(),
      conversion_rate_source: data.conversionRateSource || 'manual',
      conversion_updated_by: updatedBy || null,
      conversion_updated_at: new Date().toISOString(),
    };
  } else {
    // Disable EUR conversion - clear all conversion fields
    updateData = {
      payable_currency: null,
      conversion_rate_chf_to_eur: null,
      converted_amount_eur: null,
      conversion_justification: null,
      conversion_rate_source: null,
      conversion_updated_by: updatedBy || null,
      conversion_updated_at: new Date().toISOString(),
    };
  }

  const { data: updatedInvoice, error } = await supabase
    .from('sponsorship_invoices')
    .update(updateData)
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    console.error('Error updating invoice conversion:', error);
    throw new Error(`Failed to update invoice conversion: ${error.message}`);
  }

  return updatedInvoice as SponsorshipInvoice;
}

/**
 * Recalculate and update invoice totals
 * Call this after modifying line items
 *
 * @param invoiceId - UUID of the invoice
 * @returns Updated invoice
 */
export async function recalculateInvoiceTotals(
  invoiceId: string
): Promise<SponsorshipInvoice> {
  const supabase = createServiceRoleClient();

  // Get invoice to find deal
  const invoice = await getInvoice(invoiceId);
  if (!invoice) {
    throw new Error('Invoice not found');
  }

  // Get deal and tier
  const deal = await getDeal(invoice.deal_id);
  if (!deal) {
    throw new Error('Deal not found');
  }

  const tier = await getTier(deal.tier_id);
  if (!tier) {
    throw new Error('Tier not found');
  }

  // Get current line items and recalculate
  const lineItems = await getLineItemsForDeal(invoice.deal_id);
  const totals = computeSponsorshipInvoiceTotals(
    lineItems,
    tier,
    deal.currency as SponsorshipCurrency
  );

  const updateData: Record<string, unknown> = {
    subtotal: totals.subtotal,
    credit_applied: totals.creditApplied,
    adjustments_total: totals.adjustmentsTotal,
    total_amount: totals.total,
  };

  // Update base_amount_chf if this is a CHF deal
  if (deal.currency === 'CHF') {
    updateData.base_amount_chf = totals.total;
  }

  // If there's an active EUR conversion, recalculate the converted amount
  if (invoice.payable_currency === 'EUR' && invoice.conversion_rate_chf_to_eur) {
    const baseAmount = deal.currency === 'CHF' ? totals.total : (invoice.base_amount_chf ?? totals.total);
    updateData.converted_amount_eur = Math.round(baseAmount * invoice.conversion_rate_chf_to_eur);
    updateData.conversion_updated_at = new Date().toISOString();
  }

  const { data: updatedInvoice, error } = await supabase
    .from('sponsorship_invoices')
    .update(updateData)
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    console.error('Error recalculating invoice totals:', error);
    throw new Error(`Failed to recalculate invoice totals: ${error.message}`);
  }

  return updatedInvoice as SponsorshipInvoice;
}
