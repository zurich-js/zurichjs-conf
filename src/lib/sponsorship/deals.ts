/**
 * Sponsorship Deals Business Logic
 * CRUD operations for sponsorship deal management
 */

import { createServiceRoleClient } from '@/lib/supabase';
import type {
  SponsorshipDeal,
  SponsorshipDealWithRelations,
  SponsorshipDealListItem,
  SponsorshipDealStatus,
  CreateDealRequest,
  UpdateDealRequest,
  ListDealsQuery,
  ListDealsResponse,
} from '@/lib/types/sponsorship';
import { isValidDealStatusTransition } from '@/lib/types/sponsorship';

/**
 * Create a new sponsorship deal
 *
 * @param data - Deal creation data
 * @returns Created deal with auto-generated deal number
 */
export async function createDeal(data: CreateDealRequest): Promise<SponsorshipDeal> {
  const supabase = createServiceRoleClient();

  const { data: deal, error } = await supabase
    .from('sponsorship_deals')
    .insert({
      // Deal number is auto-generated by database trigger when empty
      deal_number: '',
      sponsor_id: data.sponsorId,
      tier_id: data.tierId,
      currency: data.currency,
      status: 'draft',
      internal_notes: data.internalNotes || null,
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating deal:', error);
    throw new Error(`Failed to create deal: ${error.message}`);
  }

  return deal as SponsorshipDeal;
}

/**
 * Get a single deal by ID
 *
 * @param dealId - UUID of the deal
 * @returns Deal or null if not found
 */
export async function getDeal(dealId: string): Promise<SponsorshipDeal | null> {
  const supabase = createServiceRoleClient();

  const { data, error } = await supabase
    .from('sponsorship_deals')
    .select('*')
    .eq('id', dealId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return null; // Not found
    }
    console.error('Error fetching deal:', error);
    throw new Error(`Failed to fetch deal: ${error.message}`);
  }

  return data as SponsorshipDeal;
}

/**
 * Get deal with all related data (sponsor, tier, line items, perks, invoice)
 *
 * @param dealId - UUID of the deal
 * @returns Deal with all relations or null if not found
 */
export async function getDealWithRelations(
  dealId: string
): Promise<SponsorshipDealWithRelations | null> {
  const supabase = createServiceRoleClient();

  // Fetch deal with sponsor and tier
  const { data: deal, error: dealError } = await supabase
    .from('sponsorship_deals')
    .select(`
      *,
      sponsor:sponsors(*),
      tier:sponsorship_tiers(*)
    `)
    .eq('id', dealId)
    .single();

  if (dealError) {
    if (dealError.code === 'PGRST116') {
      return null;
    }
    throw new Error(`Failed to fetch deal: ${dealError.message}`);
  }

  // Fetch line items
  const { data: lineItems, error: lineItemsError } = await supabase
    .from('sponsorship_line_items')
    .select('*')
    .eq('deal_id', dealId)
    .order('display_order', { ascending: true });

  if (lineItemsError) {
    throw new Error(`Failed to fetch line items: ${lineItemsError.message}`);
  }

  // Fetch perks
  const { data: perks, error: perksError } = await supabase
    .from('sponsorship_perks')
    .select('*')
    .eq('deal_id', dealId)
    .order('display_order', { ascending: true });

  if (perksError) {
    throw new Error(`Failed to fetch perks: ${perksError.message}`);
  }

  // Fetch invoice (if exists)
  const { data: invoices, error: invoiceError } = await supabase
    .from('sponsorship_invoices')
    .select('*')
    .eq('deal_id', dealId)
    .limit(1);

  if (invoiceError) {
    throw new Error(`Failed to fetch invoice: ${invoiceError.message}`);
  }

  return {
    ...deal,
    sponsor: deal.sponsor,
    tier: deal.tier,
    line_items: lineItems || [],
    perks: perks || [],
    invoice: invoices?.[0] || null,
  } as SponsorshipDealWithRelations;
}

/**
 * Update a deal
 *
 * @param dealId - UUID of the deal
 * @param data - Update data
 * @returns Updated deal
 */
export async function updateDeal(
  dealId: string,
  data: UpdateDealRequest
): Promise<SponsorshipDeal> {
  const supabase = createServiceRoleClient();

  // Build update object with only provided fields
  const updateData: Record<string, unknown> = {};

  if (data.tierId !== undefined) updateData.tier_id = data.tierId;
  if (data.currency !== undefined) updateData.currency = data.currency;
  if (data.internalNotes !== undefined) updateData.internal_notes = data.internalNotes;

  const { data: deal, error } = await supabase
    .from('sponsorship_deals')
    .update(updateData)
    .eq('id', dealId)
    .select()
    .single();

  if (error) {
    console.error('Error updating deal:', error);
    throw new Error(`Failed to update deal: ${error.message}`);
  }

  return deal as SponsorshipDeal;
}

/**
 * Update deal status with validation and timestamp tracking
 *
 * @param dealId - UUID of the deal
 * @param newStatus - New status to transition to
 * @param paidBy - Admin name (required when transitioning to 'paid')
 * @returns Updated deal
 */
export async function updateDealStatus(
  dealId: string,
  newStatus: SponsorshipDealStatus,
  paidBy?: string
): Promise<SponsorshipDeal> {
  const supabase = createServiceRoleClient();

  // Get current deal status
  const { data: currentDeal, error: fetchError } = await supabase
    .from('sponsorship_deals')
    .select('status')
    .eq('id', dealId)
    .single();

  if (fetchError) {
    throw new Error(`Failed to fetch deal: ${fetchError.message}`);
  }

  const currentStatus = currentDeal.status as SponsorshipDealStatus;

  // Validate transition
  if (!isValidDealStatusTransition(currentStatus, newStatus)) {
    throw new Error(
      `Invalid status transition from '${currentStatus}' to '${newStatus}'`
    );
  }

  // Build update with appropriate timestamp
  const updateData: Record<string, unknown> = { status: newStatus };
  const now = new Date().toISOString();

  switch (newStatus) {
    case 'offer_sent':
      updateData.offer_sent_at = now;
      break;
    case 'invoiced':
      updateData.invoiced_at = now;
      break;
    case 'invoice_sent':
      updateData.invoice_sent_at = now;
      break;
    case 'paid':
      updateData.paid_at = now;
      updateData.paid_by = paidBy || null;
      break;
  }

  const { data: deal, error } = await supabase
    .from('sponsorship_deals')
    .update(updateData)
    .eq('id', dealId)
    .select()
    .single();

  if (error) {
    console.error('Error updating deal status:', error);
    throw new Error(`Failed to update deal status: ${error.message}`);
  }

  return deal as SponsorshipDeal;
}

/**
 * List deals with filtering and pagination
 *
 * @param query - Query parameters
 * @returns Deals list with total count
 */
export async function listDeals(
  query: ListDealsQuery = {}
): Promise<ListDealsResponse> {
  const supabase = createServiceRoleClient();
  const { status, tierId, currency, sponsorId, search, page = 1, limit = 20 } = query;

  let queryBuilder = supabase
    .from('sponsorship_deals')
    .select(
      `
      *,
      sponsor:sponsors(id, company_name, contact_name, contact_email, logo_url),
      tier:sponsorship_tiers(id, name),
      invoice:sponsorship_invoices(id, invoice_number, total_amount)
    `,
      { count: 'exact' }
    );

  // Apply filters
  if (status) {
    queryBuilder = queryBuilder.eq('status', status);
  }

  if (tierId) {
    queryBuilder = queryBuilder.eq('tier_id', tierId);
  }

  if (currency) {
    queryBuilder = queryBuilder.eq('currency', currency);
  }

  if (sponsorId) {
    queryBuilder = queryBuilder.eq('sponsor_id', sponsorId);
  }

  // Apply pagination
  const offset = (page - 1) * limit;
  queryBuilder = queryBuilder
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);

  const { data, error, count } = await queryBuilder;

  if (error) {
    console.error('Error listing deals:', error);
    throw new Error(`Failed to list deals: ${error.message}`);
  }

  // If searching, filter results (Supabase doesn't support searching across joined tables easily)
  let filteredData = data || [];
  if (search) {
    const searchLower = search.toLowerCase();
    filteredData = filteredData.filter((deal) => {
      const sponsor = deal.sponsor as { company_name: string } | null;
      return (
        deal.deal_number.toLowerCase().includes(searchLower) ||
        sponsor?.company_name?.toLowerCase().includes(searchLower)
      );
    });
  }

  // Transform invoice array to single object
  const transformedData = filteredData.map((deal) => ({
    ...deal,
    invoice: Array.isArray(deal.invoice) ? deal.invoice[0] || null : deal.invoice,
  }));

  return {
    deals: transformedData as SponsorshipDealListItem[],
    total: count || 0,
  };
}

/**
 * Delete a deal
 * Only allowed for draft status
 *
 * @param dealId - UUID of the deal
 */
export async function deleteDeal(dealId: string): Promise<void> {
  const supabase = createServiceRoleClient();

  // Check current status
  const { data: deal, error: fetchError } = await supabase
    .from('sponsorship_deals')
    .select('status')
    .eq('id', dealId)
    .single();

  if (fetchError) {
    throw new Error(`Failed to fetch deal: ${fetchError.message}`);
  }

  if (deal.status !== 'draft') {
    throw new Error('Can only delete deals in draft status');
  }

  const { error } = await supabase
    .from('sponsorship_deals')
    .delete()
    .eq('id', dealId);

  if (error) {
    console.error('Error deleting deal:', error);
    throw new Error(`Failed to delete deal: ${error.message}`);
  }
}
